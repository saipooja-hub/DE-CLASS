DAY-6:

subquery:
	A subquery in SQL is a SELECT statement nested inside another SQL statement, such as SELECT, INSERT, UPDATE, or DELETE, or within another subquery.
1.where clause
2.column
3.derived table
4.co-related subquery.

1.subquery:
bring data from other tables.it is just referencing other tables.

SELECT first_name, last_name	---outer query
FROM sakila.customer

WHERE address_id IN (
    SELECT address_id	---Inner query
    FROM sakila.customer
     WHERE customer_id = 1
);

#in the time of execution first we will execute inner query and then execute outer query.

SELECT actor_id, first_name, last_name
FROM sakila.actor
WHERE actor_id IN (
    SELECT actor_id	--subquery
    FROM sakila.film_actor
    GROUP BY actor_id
    HAVING COUNT(film_id) > 10
);
#i had a condition where actor-id column should be present in film actor table.

#SUB QUERY IN SELECT:
SELECT actor_id,
       first_name,
       last_name,
       (
           SELECT COUNT(*)
           FROM sakila.film_actor
           WHERE film_actor.actor_id = actor.actor_id
       ) AS film_count
FROM sakila.actor;

#DERIVED TABLE:
	trying to create a new table only at the query level.
SELECT a.actor_id, a.first_name, a.last_name, fa.film_count
FROM sakila.actor a
JOIN (
    SELECT actor_id, COUNT(film_id) AS film_count
    FROM sakila.film_actor
    GROUP BY actor_id
    HAVING COUNT(film_id) > 10
) fa ON a.actor_id = fa.actor_id;

SELECT customer_id, total_spent
FROM (
    SELECT customer_id, SUM(amount) AS total_spent
    FROM sakila.payment
    GROUP BY customer_id
    ORDER BY total_spent DESC
    LIMIT 5
) AS top_customers;

#there are some disadvantages on sub query it creates a lot of complexity

SELECT *
FROM (
    SELECT last_name,
           CASE 
               WHEN LEFT(last_name, 1) BETWEEN 'A' AND 'M' THEN 'Group A-M'
               WHEN LEFT(last_name, 1) BETWEEN 'N' AND 'Z' THEN 'Group N-Z'
               ELSE 'Other'
           END AS group_label
    FROM sakila.customer
) AS grouped_customers 
WHERE group_label = 'Group N-Z';

SELECT customer_id, amount
FROM sakila.payment
WHERE amount > (
    SELECT AVG(amount)
    FROM sakila.payment
);

#when sub query fail 

SELECT first_name,
       (SELECT address_id FROM sakila.address WHERE district = 'California'  ) AS cali_address
FROM sakila.customer;

#co related subqueries 
-- A correlated subquery is a subquery that:
-- Refers to a column from the outer (main) query
-- Is executed once for each row in the outer query
SELECT title,
  (SELECT COUNT(*)
   FROM sakila.film_actor fa
   WHERE fa.film_id = f.film_id) AS actor_count
FROM sakila.film f;

SELECT payment_id, customer_id, amount, payment_date
FROM sakila.payment p1
WHERE amount > (
    SELECT AVG(amount)
    FROM sakila.payment p2
    WHERE p2.customer_id = p1.customer_id
);

#CARDINALITY RELATIONSHIP IN SQL:
	the uniqueness of data values within a column and the nature of the relationship between database tables

1.one to one relationship.
2.one to many
3.many to many.
4.many to many.

1.one to one:
	user table--user id is primary key
	order table--order id is primary key
	products--these three are related to each other
	userprofile table--active and inactiveness of table
	friendship table -- to mantain relationship.

1.one to one cardinality:
	User table and user profile table maintains one to one relationship.

2.one to many:
	the user places many orders.
3.many to one:
	many orders are placed by one customer.
4.many to many:
	many to many can be achieved by using bridge table.
	one user can be friend with many so this is called many to many cardinality relation ship between tables.

	





